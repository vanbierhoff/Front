const swiperEvent = new CustomEvent('swipe', {    'detail': event,    bubbles : true,});class Swiper {    constructor(el,parents){        this.minTime = 70;        this.maxTime = 1500;        this.el = el;        this.parent = parents;        this.textDescript = document.querySelector('.check__description')    }    /**     *     * @param e  - event     * @param direction {string } - направление перемещения.     * @param touchStart - {number} - начальная позиция в момент touchstart     */    move(e,direction,touchStart){        let touch = e.targetTouches[0];  // получаем данные по событию tocuh        let positionX = this.el.style.left        let newPosition = `${touch.pageX - this.el.offsetWidth/2}px`        switch (direction) {            // Перемещение вправо            case 'right':                if (touch.pageX > touchStart){                    this.el.style.left  =  `${touch.pageX - this.el.offsetWidth/2}px`                }                break            // Перемещение влево            case 'left':                if (touch.pageX < touchStart){                this.el.style.left  =  `${touch.pageX - this.el.offsetWidth/2}px`            }                break        }    }    clickEvent(){    }    swipeEvent(direction) {        switch (direction) {            case 'right':                this.el.classList.add('checkPracticMoveRight')                this.parent.classList.add('checkBackground')                this.textDescript.classList.toggle('check__description_right')                this.el.classList.remove('checkPracticMoveRightRev')                this.parent.classList.remove('checkBackgroundRev')                // style.left устанвливается в позицию, в которой был touchEnd, с помощью асинхронности задаем после анимации необходисмое положение                setTimeout(()=>{                  let parentWidth =  this.parent.offsetWidth                    let elWidth = this.el.offsetWidth+11                    this.el.style.left = parentWidth-elWidth+`px`                },0)                break            case 'left':                this.el.classList.add('checkPracticMoveRightRev')                this.parent.classList.add('checkBackgroundRev')                this.textDescript.classList.toggle('check__description_right')                this.el.classList.remove('checkPracticMoveRight')                this.parent.classList.remove('checkBackground')                // style.left устанвливается в позицию, в которой был touchEnd, с помощью асинхронности задаем после анимации необходисмое положение                setTimeout(()=>{                    this.el.style.left = `0%`                },0)                break        }    }}class SwipeTouch extends Swiper {    constructor(el, parents) {        super(el, parents);        this.init = false        this.el = el;        this.direction = 'right'        this.startTime = null;            // начало события        this.deltaTime = null;           // длительность события        this.startPosition = this.el.offsetLeft-4     // вычитаем отступ margin        this.startPos        this.__initTouch()    }    /**     *     * @private     *     * Добавляет слушателя события touchstart  - начало события касания     * Добавляет слушателя события  touchend - окончаение события касания экрана     *  Добавляет слушателя события  touchmove - перемещение точки касания по экрану     * @method move(e) - родительский метод, выполняющий перемещение объекта     *     *     */    __initTouch() {       this.el.addEventListener("touchstart", e => {            this.startTime = new Date().getTime();           this.deltaTime = null           this.el.addEventListener("touchmove", e => {                 let thisTime = new Date().getTime()                 // длительность события                this.deltaTime = thisTime - this.startTime              // вызываем родительский метод перемещения - this.el                super.move(e, this.direction,this.startPosition)            });        });        this.el.addEventListener('touchend', e => {            let touch = e.targetTouches[0];            let xAbs = Math.abs(this.startPosition - this.el.offsetLeft)            // проверяем являлось ли совершенное движение свайпом            if (this.deltaTime > this.minTime && this.deltaTime < this.maxTime                && xAbs > 30 && xAbs < 150) {                    super.swipeEvent(this.direction)                    this.reverseInit()            } else if (this.deltaTime === null ) {                super.swipeEvent(this.direction)                this.reverseInit()            } else {                    this.el.style.left = this.startPosition+"px"            }        })    }    /**     * метод делает реверс свайла, если отслеживался свайл влево, будет отслеживаться свайп вправо и наоборот     */    reverseInit(){        switch (this.direction) {            case 'right':                this.direction = 'left'            break;            case 'left':                this.direction = 'right'                break        }        this.init = false        setTimeout(()=>{            this.startPosition = this.el.offsetLeft-4        },500)    }    set startPosition(value){        let x = typeof(value) === 'string'? 0 : value        if(this.init === false ){            this.startPos = x            this.init = true        }    }    get startPosition(){       return this.startPos    }}let parent = document.getElementById('swipe-block')let elem = document.getElementById('swiper')let elemSwipe = document.getElementById('swiper')elem = new Swiper(elem, parent)elemSwipe = new SwipeTouch(elemSwipe,parent)function swiperPositon() {    let windowWidth = window.innerWidth    let footer = document.querySelector('footer')    let chekPratcicFix = document.querySelector('.check__practic_fixed')    chekPratcicFix.style.bottom = `${footer.offsetHeight+5}px`    let difference = (windowWidth - chekPratcicFix.offsetWidth)    chekPratcicFix.style.left = difference/2+ "px"}swiperPositon()